#title: "XCMS.function"
#author: "Laura Hmelo"
#last update: "January 13, 2017"

# This script contains several major functions (and a couple of embedded functions), which are # described under their respective headings:
# xcmsfunction (extractiontype, excludedsamples)
# samplesetmaker (extractiontype, excludedsamples)
# qcplotter (xset, sampleset, xset.filtered, MFs)
# 
# 
# xcmsfunction----
# This script uses XCMS to generate a list of peaks that have been
# aligned, RT corrected, realigned, and recursively filled. 
# 
# Before running the function:
# 1. Define outputpath and mzxmlpath
# 2. Define extractiontype in function call
# 
# Input:
# 1. .mzXML sample files unbinned in a single folder
# 
# Output is a list containing:
# 1. a processed xcmsSet object (xset3)
# 2. a data.frame containing a list of peaks that have been
# aligned, RT corrected, realigned, and recursively filled (xset.allpeaks)

xcmsfunction <- function(extractiontype, excludedsamples=NULL) {

library(xcms)
library(RANN)
library(Biobase)
library(seqinr)
library(plyr)
library(lubridate)
library(timeDate)
library(ggplot2)
library(stringr)
require(reshape2)
require(dplyr)
  


# Getting samples and peak picking -------------------------------------------------------

setwd(mzxmlpath)

Samples <- list.files( getwd(), pattern=".mzXML", full.names=F, 
                      recursive = TRUE) # looking for appropriate files

sampleset <- Samples[grepl(extractiontype, Samples)]

if (is.character(excludedsamples)) {
  sampleset <- sampleset[!grepl(excludedsamples, sampleset)]
  } 

print(sampleset)

xset <- xcmsSet(
  sampleset, 
  method = "centWave",  
  ppm= PPM, 
  peakwidth= PeakWidth,
  snthresh= SNthresh, 
  mzCenterFun="apex", 
  prefilter= Prefilter ,
  integrate = 1, 
  fitgauss= TRUE)


print("peak picking complete")

# Initial peak alignment -------------------------------------------------------

xset <- group(
  xset, 
  method="density", 
  bw= BW, 
  minfrac= MinFrac,
  minsamp= Minsamp, 
  mzwid= MzWid, 
  max= MAX)

setwd(outputpath)
save(xset, file=paste(extractiontype, "xset.RData", sep="."))

print("Initial peak alignment complete")

# RT correction -------------------------------------------------------


xset2 <- retcor(
  xset, 
  method = "peakgroups",
  missing = Missing, 
  extra = Extra, 
  smooth = "loess",
  family = "symmetric", 
  plottype = NULL
)


print("RT correction complete")

# Peak align the RT-corrected data -------------------------------------------------------

xset2 <- group(
  xset2, 
  method="density", 
  minsamp=Minsamp, 
  minfrac=MinFrac, 
  mzwid= MzWid, 
  bw= BW, 
  max=MAX)


xset.unfilled <- peakTable(xset2)

setwd(outputpath)
write.csv(xset.unfilled, file=paste(extractiontype, "Unfilled_peaks.csv", sep="."))
save(xset2, file=paste(extractiontype, "xset2.RData", sep="."))

print("second peak alignment done")

# Recursive peak filling -------------------------------------------------------

xset3 <- fillPeaks(xset)

setwd(outputpath)
save(xset3, file=paste(extractiontype, "xset3.RData", sep="."))

print("recursive peak filling is done")

#xset3 is the input file for CAMERA or diffreport. 

# Generate a data.frame with all the peaks----

xset.allpeaks <- peakTable(xset3)
xset.allpeaks$MassFeature <- paste("I", round((xset.allpeaks$mz),digits=4), 
                                       "R", round( xset.allpeaks$rt/60, digits=2), sep="")
xset.allpeaks$groupname <- groupnames(xset3)
xset.allpeaks$RT <- xset.allpeaks$rt/60

setwd(outputpath)
write.csv(xset.allpeaks, file=paste(extractiontype, "Allpeaks.table","csv",sep="."))

print("allpeaks data table is saved")

XCMSlist <- list(xset3, xset.allpeaks)
return(invisible(XCMSlist))

}

# samplesetmaker----
#This function defines a group of samples based on the extraction phase. This function is used to define the sampleset variable used in the subsequent function, qcplotter.

samplesetmaker <- function(extractiontype, excludedsamples=NULL){
  
  setwd(mzxmlpath)
  
  Samples <- list.files( getwd(), pattern=".mzXML", full.names=F, 
                         recursive = TRUE) # looking for appropriate files
  
  sampleset <- Samples[grepl(extractiontype, Samples)]
  
  if (is.character(excludedsamples)) {
    sampleset <- sampleset[!grepl(excludedsamples, sampleset)]
  } 
  
  return(sampleset)
}


#qcplotter----
#This function plots EICs for mass features designated in MFs.  
#
#Inputs:
#1. a processed xcmsset object (xset, probably xset3)
#2. xset.filtered, generated by mfmaker
#3. MFs, generated by mfmaker
#4. sampleset, generated by function samplesetmaker
#
#Outputs:
#1. a pdf file containing raw and corrected EICs for mass features designated in list, MF.

qcplotter <- function(xset, sampleset, xset.filtered, MFs){

EIC.uncorrected <- list()
EIC.corrected <- list()

# This next step will take some time to process, so don't expect instant results. 
setwd(mzxmlpath)
RandSamp <- round(runif(1, min = 1, max = length(sampleset)))

#for (i in 1:length(MFs)){   
#  EIC.uncorrected[[i]] <- getEIC(xset, rt="raw", groupidx=MFs[i], sampleidx=Aq.Samples)
#  EIC.corrected[[i]] <- getEIC(xset, rt="corrected", groupidx=MFs[i], sampleidx=Aq.Samples)
#}

for (i in 1:length(MFs)){   
  EIC.uncorrected[[i]] <- getEIC(xset, rt="raw", groupidx=MFs[i])
  EIC.corrected[[i]] <- getEIC(xset, rt="corrected", groupidx=MFs[i])
}



ColRainbow <- colorRampPalette(c("green", "blue", "purple")) 
MyColors <- c(ColRainbow(RandSamp-1), "red")

#setwd(mzxmlpath)

#
LastSamp <- sampleset[RandSamp[length(RandSamp)]]

xset.raw <- xcmsRaw(LastSamp, profstep=0.01, profmethod="bin")


setwd(outputpath)
pdf(paste(Sys.Date(), extractiontype, "xset_QC.pdf", sep = "."), 8.5,11)

par(mfrow=c(4,3), mar=c(3,3,3,0.5)) 
for(i in 1:length(MFs)){
  plot(EIC.uncorrected[[i]], xset, groupidx=1, rtrange=60, col=MyColors, main=MFs[i])
  mtext(paste(i, xset.filtered$MassFeature[xset.filtered$groupname == MFs[i]]), 
        side=3, line=-1, adj=0, padj=0, cex=0.8)
  plot(EIC.corrected[[i]], xset, groupidx=1, rtrange=60, col=MyColors)
  RT <- xset.filtered$rt[xset.filtered$groupname == MFs[i]] 
  RTRange <- c(RT-30, RT+30)
  mz <- xset.filtered$mz[xset.filtered$groupname == MFs[i]] 
  mzRange <- c(mz-0.02, mz+0.02)
  mzRange.poly.low <- mz- mz*(0.5*PPM)/1e6
  mzRange.poly.up <- mz*(0.5*PPM)/1e6 + mz
  plotRaw(xset.raw, mzrange=mzRange, rtrange=RTRange, log=FALSE) 
  abline(h=mz, lty=2, col="gray35")
  #mtext(paste("abund =", round(xset.filtered[
  # xset.filtered$groupname == MFs[i]])), 
  #SampCol[RandSamp[length(RandSamp)]]], digits=0)), 
  #   side=3, line=-1, adj=0, padj=0, cex=0.8)
  polygon(c(RTRange[2], RTRange[1], RTRange[1], RTRange[2]), 
          c(mzRange.poly.up, mzRange.poly.up,
            mzRange.poly.low, mzRange.poly.low), 
          col=col2alpha("blue", alpha=0.1), border=NA)
  abline(v=RT, lty=2, col="gray35")
}
dev.off()

return("pdf saved")
}


